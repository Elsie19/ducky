#!/bin/bash
set -eu
shopt -s gnu_errfmt
export LC_ALL=C
bold=$(tput bold)
normal=$(tput sgr0)

INPUT="${1}"

unset vars
# associative arrays go brr
declare -A vars

function replace_var() {
	true
}

function errorfmt() {
	printf '%s\n' "ERROR: $*"
}
keys=('#' 'print' 'var' 'unset' 'if')
while IFS= read -r line; do
	# get first key in line: "foo bar baz" -> "foo"
	value="${line%% *}"
	# if line does not contain value and value is not empty (newline), error out
	if [[ ! " ${keys[*]} " =~ " ${value} " ]] && [[ ! ${value:-null} == null ]]; then
		errorfmt "(${bold}$line${normal}) is not a valid command"
		exit 1
	fi
	# yoinks comments
	if [[ "${line}" =~ ^#* ]]; then
		true
	fi
	# print statement
	if [[ "${line}" =~ ^print ]]; then
		# if line contains a {}, which means a variable is used
		if [[ "${line}" == *"{"* ]]; then
			# match for both {}
			if grep --color=none -vE '{.*}' <<< "${line}" 2>/dev/null; then
				errorfmt "Line does not contain an equal number of brackets"
				exit 1
			else
				# first get the actual variable names
				mapfile -t variable_names < <(grep --color=none -oP '(?<={).*?(?=})' <<< "${line}")
				looped_line="${line}"
				for i in "${variable_names[@]}"; do
					looped_line="$(sed "s/{$i}/${vars[$i]}/g" <<< "${looped_line}")"
				done
				printf '%s\n' "${looped_line#print }"
				unset variable_names looped_line
			fi
		else
			# normal print statement
			printf '%s\n' "${line#print }"
		fi
	fi

	if [[ "${line}" =~ ^var ]]; then
		key="$(awk '{print $2}' <<< "${line}")"
		value="$(awk '{print $3}' <<< "${line}")"
		vars["${key}"]="${value}"
		unset key value
	fi

	if [[ "${line}" =~ ^unset ]]; then
		key="${line#unset }"
		set +u
		if [[ -z ${vars[$key]} ]]; then
			errorfmt "$key does not exist"
			exit 1
		fi
		set -u
		unset -v "vars[$key]"
	fi

	if [[ ${line} =~ ^if ]]; then
		if grep --color=none -vE '(.*)' <<< "${line}" 2>/dev/null; then
			errorfmt "(${bold}$line${normal}) does not contain an equal number of brackets"
			exit 1
		fi
	fi
done < "${INPUT}"
